
*02*	Mappings and Abbreviations

This chapter tells how to create short-cuts for frequently used long
commands.

|02_1|	Introduction
|02_2|	Key mappings
|02_3|	Mappings and modes
|02_4|	Remapping
|02_5|	Recursive mapping
|02_6|	Delete a mapping
|02_7|	Abbreviations


===========================================================================
*02_1*	Introduction

A mapping enables you to bind a set of Vim commands to a single key.
Suppose, for example, that you need to surround certain words with curly
braces.  In other words, you need to change a word such as "amount" into
"{amount}".  With the :map command, you can tell Vim that the F5 key does
this job.  The command is as follows: >

	:map <F5> i{<Esc>ea}<Esc>

Note: When entering this command, you must enter <F5> by typing four
characters.  Similarly, <Esc> is not entered by pressing the <Esc> key, but
by typing five characters.  Watch out for this difference when reading the
manual!

Let's break this down:
    <F5>    The F5 function key.  This is the trigger key that causes the
	    command to be executed as the key is pressed.
    i{<Esc> Insert the { character.  The <Esc> key ends Insert mode.
    e	    Move to the end of the word.
    a}<Esc> Append the } to the word.

After you execute the ":map" command, all you have to do to put {} around a
word is to put the cursor on the first character and press F5.

In this example, the trigger is a single key; it can be any string.  But
when you use an existing Vim command, that command will no longer be
available.  You better avoid that.

One key that can be used with mappings is the backslash.  Since you probably
want to define more than one mapping, add another character.  You could map
"\p" to add parens around a word, and "\c" to add curly braces, for example:
>

	:map \p i(<Esc>ea)<Esc>
	:map \c i{<Esc>ea}<Esc>

You need to type the \ and the p quickly after another, so that Vim knows
they belong together.

The ":map" command (with no arguments) lists your current mappings.  At
least the ones for Normal mode.

===========================================================================
*02_2*	Key mappings

The simplest form is that one key is mapped to a sequence of keys.  Since
the function keys, except <F1>, have no predefined meaning in Vim, these are
a good choice to map.  Example: >

	:map <F2> GoDate: <Esc>:read !date<CR>kJ

This shows how three modes are used.  After going to the last line with "G",
the "o" command opens a new line and starts Insert mode.  The text "Date: "
is inserted and <Esc> takes you out of insert mode.

Notice the use of special keys inside <>.  This is called angle bracket
notation.  You type these as separate characters, not by pressing the key
itself.  This makes the mappings better readable and you can copy and paste
the text without problems.

The ":" character takes Vim to the command line.  The ":read !date" command
reads the output from the "date" command and appends it below the current
line.  The <CR> is required to execute the ":read" command.  At this point
of execution the text looks like this:

	Date:  ~
	Fri Jun 15 12:54:34 CEST 2001 ~

Now "kJ" moves the cursor up and joins the lines together.


===========================================================================
*02_3*	Mapping and modes

The ":map" command defines remapping for keys in Normal mode.  You can also
define mappings for other modes.  For example, ":imap" applies to Insert
mode.  You can use it to insert a date below the cursor: >

	:imap <F2> <CR>Date: <Esc>:read !date<CR>kJ

It looks a lot like the mapping for <F2> in Normal mode, only the start is
different.  The <F2> mapping for Normal mode is still there.  Thus you can
map the same key differently for each mode.

Notice that, although this mapping starts in Insert mode, it ends in Normal
mode.  If you want it to continue in Insert mode, append a "a" to the
mapping.

Here is an overview of map commands and in which mode they work:

	:map		Normal, Visual and Operator-pending
	:vmap		Visual
	:nmap		Normal
	:omap		Operator-pending
	:map!		Insert and Command-line
	:imap		Insert
	:cmap		Command-line

Operator-pending mode is when you typed an operator character, such as "d"
or "y", and you are expected to type the motion command or a text object.
Thus when you type "dw", the "w" is entered in operator-pending mode.

Suppose that you want to define <F7> so that the command d<F7> deletes a C
program block (text enclosed in curly braces, {}).  Similarly y<F7> would
yank the program block into the unnamed register.  Therefore, what you need
to do is to define <F7> to select the current program block.  You can do
this with the following command: >

	:omap <F7> a{

This causes <F7> to perform a select block "a{" in operator-pending mode,
just like you typed it.  This mapping is useful if typing a { on your
keyboard is a bit difficult.


Listing mappings ~

To see the currently defined mappings, use ":map" without arguments.  Or one
of the variants that include the mode in which they work.  The output could
look like this:

	   _g		 :call MyGrep(1)<CR> ~
	v  <F2>		 :s/^/> /<CR>:noh<CR>`` ~
	n  <F2>		 :.,$s/^/> /<CR>:noh<CR>`` ~
	   <xHome>	 <Home>
	   <xEnd>	 <End>


The first column of the list shows in which mode the mapping is effective.
This is "n" for Normal mode, "i" for Insert mode, etc.  A blank is used for
a mapping defined with ":map", thus effective in both Normal and Visual
mode.

One useful purpose of listing the mapping is to check if special keys in <>
form have been recognized (this only works when color is supported).  For
example, when <Esc> is displayed in color, it stands for the escape
character.  When it has the same color as the other text, it is five
characters.


===========================================================================
*02_4*	Remapping

The result of a mapping is inspected for other mappings in it.  For example,
the mappings for <F2> above could be shortened to: >

	:map <F2> G<F3>
	:imap <F2> <Esc><F3>
	:map <F3>  oDate: <Esc>:read !date<CR>kJ

For Normal mode <F2> is mapped to go to the last line, and then behave like
<F3> was pressed.  In Insert mode <F2> stops Insert mode with <Esc> and then
also uses <F3>.  Then <F3> is mapped to do the actual work.

Suppose you want to use the "Q" command to format text (this was so in old
versions of Vim).  This mapping will do it: >

	:map Q gq

But, in rare cases you need to use Ex mode anyway.  Let's map "gQ" to Q, so
that you can still go to Ex mode: >

	:map gQ Q

What happens now is that when you type "gQ" it is mapped to "Q".  So far so
good.  But then "Q" is mapped to "gq", thus typing "gQ" results in "gq", and
you don't get to Ex mode at all.

To avoid keys to be mapped again, use the ":noremap" command: >

	:noremap gQ Q

Now Vim knows that the "Q" is not to be inspected for mappings that apply to
it.  There is a similar command for every mode:

	:noremap	Normal, Visual and Operator-pending
	:vnoremap	Visual
	:nnoremap	Normal
	:onoremap	Operator-pending
	:noremap!	Insert and Command-line
	:inoremap	Insert
	:cnoremap	Command-line


===========================================================================
*02_5*	Recursive mapping

When a mapping triggers itself, it will run forever.  This can be used to
repeat an action an unlimited number of times.

For example, you have a list of files that contain a version number in the
first line.  You edit these files with "vim *.txt".  You are now editing the
first file.  Define this mapping: >

	:map ,, :s/5.1/5.2/<CR>:wnext<CR>,,

Now you type ",,".  This triggers the mapping.  It replaces "5.1" with "5.2"
in the first line.  Then it does a ":wnext" to write the file and edit the
next one.  The mapping ends in ",,".  This triggers the same mapping again,
thus doing the substitution, etc.

This continues until there is an error.  In this case it could be a file
where the substitute command doesn't find a match for "5.1".  You can then
make a change to insert "5.1" and continue by typing ",," again.  Or the
":wnext" fails, because you are in the last file in the list.

When a mapping runs into an error halfway, the rest of the mapping is
discarded.  CTRL-C interrupts the mapping (CTRL-Break on MS-Windows).


===========================================================================
*02_6*	Delete a mapping

To remove a mapping use the ":unmap" command.  Again, the mode the unmapping
applies to depends on the command used:

	:unmap		Normal, Visual and Operator-pending
	:vunmap		Visual
	:nunmap		Normal
	:ounmap		Operator-pending
	:unmap!		Insert and Command-line
	:iunmap		Insert
	:cunmap		Command-line

There is a trick to define a mapping that works in Normal and
Operator-pending mode, but not in Visual mode.  First define it for all
three modes, then delete it for Visual mode: >

	:map <C-A> /---><CR>
	:vunmap <C-A>

Notice that the five characters "<C-A>" stand for the single key CTRL-A.

To remove all mappings use the :mapclear command.  You can guess the
variations for different modes by now.  Be careful with this command, it
can't be undone.


===========================================================================
*02_7*	Abbreviations

Abbreviations are a lot like Insert mode mappings.  The arguments are
handled in the same way.  The main difference is the way they are triggered.
An abbreviation is triggered by typing a non-word character after the word.
A mapping is triggered when typing the last character.

Abbreviations are used in Insert mode, Replace mode and Command-line mode.
If you enter a word that is an abbreviation, it is replaced with the word it
stands for.  This can be used to save typing for often used long words.  And
you can use it to automatically correct obvious spelling errors. >

	:ab[breviate] sj SoftJin
	:ia[bbrev] hte the

The abbreviation "sj" works in all modes while "hte" works only in insert
and replace mode. Similarly you can use >

	:ca[bbrev]

Note: Abbreviations are never recursive. So you can use the following
abbreviation for your c programs >

	:iab if if ()<Left>

Using any of the abbreviation call without arguments would list the current
abbreviations. You can use the following commands to remove any
abbreviations. >

	:una[bbreviate]
	:iuna[bbrev]
	:cuna[bbrev]

===========================================================================

vim:ft=help:tw=76:ts=8:nomodifiable
